<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Event Data Inspector</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      background-color: #1A202C; /* Dark background */
      color: #E2E8F0; /* Light text */
      font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
    }
    .container {
      max-width: 1024px;
      margin: 0 auto;
      padding: 1rem;
    }
    .event-card {
      background-color: #2D3748; /* Darker card background */
      border: 1px solid #4A5568; /* Grey border */
      border-radius: 0.5rem;
      padding: 1rem;
      margin-bottom: 1rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    .event-card.is-error {
      border-left: 4px solid #EF4444; /* Red border for errors */
      background-color: #2C1D1D; /* Reddish background for errors */
    }
    .event-card.is-event {
      border-left: 4px solid #3B82F6; /* Blue border for events */
      background-color: #1D232C; /* Bluish background for events */
    }
    pre {
      white-space: pre-wrap;
      word-break: break-all;
      background-color: #171923; /* Even darker for code blocks */
      padding: 0.75rem;
      border-radius: 0.25rem;
      overflow-x: auto; /* Allow horizontal scrolling for long lines */
    }
    .badge {
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.75rem;
      font-weight: 600;
    }
    .badge-error {
      background-color: #DC2626; /* Red */
    }
    .badge-event {
      background-color: #2563EB; /* Blue */
    }
  </style>
</head>
<body>
  <div class="container">
    <h1 class="text-3xl font-bold text-center my-6">Event Data Inspector ðŸ”¬</h1>
    <p class="text-center text-gray-400 mb-6">Fetches data from <code>/api/events</code> every 5 seconds and displays raw payload, extracted messages, and error classification.</p>
    
    <div id="status" class="text-center text-gray-400 mb-4">Connecting...</div>

    <div id="eventsList">
      <!-- Events will be loaded here -->
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const eventsList = document.getElementById('eventsList');
      const statusElement = document.getElementById('status');
      const displayedEventIds = new Set();
      const MAX_DISPLAY_EVENTS = 50; // Limit to keep the page performant for diagnostics

      /**
       * Safely gets a nested property from an object.
       * @param {object} obj - The object to traverse.
       * @param {string} path - The dot-separated path to the property.
       * @returns {*} The value of the property or undefined.
       */
      const getNestedProperty = (obj, path) => {
          return path.split('.').reduce((acc, part) => acc && acc[part], obj);
      };

      /**
       * Extracts error messages from the event object based on predefined paths.
       * @param {object} eventData - The 'event' object from the API response.
       * @returns {string[]} An array of unique error messages.
       */
      const extractErrorMessages = (eventData) => {
          const messages = new Set();
          
          // Paths to check at the top level of 'eventData'
          const topLevelPaths = [
              'metrics.statusSummary.errors',
              'metrics.recordSummary.failedInfo',
              'metrics.recordSummary.skippedInfo', 
          ];

          topLevelPaths.forEach(path => {
              const items = getNestedProperty(eventData, path);
              if (Array.isArray(items)) {
                  items.forEach(item => {
                      if (item && item.message) messages.add(item.message);
                  });
              }
          });

          // Check paths within activities array
          const activities = getNestedProperty(eventData, 'activities');
          if (Array.isArray(activities)) {
              activities.forEach(activity => {
                  if (activity) {
                      // activity.statusSummary.errors[].message
                      const activityStatusErrors = getNestedProperty(activity, 'statusSummary.errors');
                      if (Array.isArray(activityStatusErrors)) {
                          activityStatusErrors.forEach(err => {
                              if (err && err.message) messages.add(err.message);
                          });
                      }
                      
                      // activity.statusSummary.extensions.errors[].message
                      const activityExtensionErrors = getNestedProperty(activity, 'statusSummary.extensions.errors');
                      if (Array.isArray(activityExtensionErrors)) {
                          activityExtensionErrors.forEach(err => {
                              if (err && err.message) messages.add(err.message);
                          });
                      }
                      
                      // activity.statusSummary.extensions.errorDetail
                      const errorDetail = getNestedProperty(activity, 'statusSummary.extensions.errorDetail');
                      if (typeof errorDetail === 'string' && errorDetail) {
                          messages.add(errorDetail);
                      }

                      // activity.recordSummary.failedInfo[].message
                      const activityFailedInfo = getNestedProperty(activity, 'recordSummary.failedInfo');
                      if (Array.isArray(activityFailedInfo)) {
                          activityFailedInfo.forEach(info => {
                              if (info && info.message) messages.add(info.message);
                          });
                      }

                      // activity.recordSummary.skippedInfo[].message
                      const activitySkippedInfo = getNestedProperty(activity, 'recordSummary.skippedInfo');
                      if (Array.isArray(activitySkippedInfo)) {
                          activitySkippedInfo.forEach(info => {
                              if (info && info.message) messages.add(info.message);
                          });
                      }
                  }
              });
          }
          return Array.from(messages);
      };

      async function fetchAndDisplayEvents() {
        try {
          statusElement.textContent = 'Fetching data...';
          const res = await fetch('/api/events');
          if (!res.ok) {
            throw new Error(`HTTP error! status: ${res.status}`);
          }
          const data = await res.json();
          statusElement.textContent = `Last updated: ${new Date().toLocaleTimeString()} (Total events in backend: ${data.length})`;

          const newEventsToDisplay = [];

          data.forEach(e => {
            const eventId = e.id || e.timestamp; 
            if (!displayedEventIds.has(eventId)) {
                newEventsToDisplay.push(e);
                displayedEventIds.add(eventId);
            }
          });
          
          // Sort new events by timestamp to display newest first
          newEventsToDisplay.sort((a, b) => b.timestamp - a.timestamp);

          newEventsToDisplay.forEach(eventData => {
            const card = document.createElement('div');
            card.className = 'event-card';

            const extractedMessages = extractErrorMessages(eventData.event);
            const isFailedStatus = eventData.event.metrics && eventData.event.metrics.statusSummary && 
                                   (eventData.event.metrics.statusSummary.status === 'failed' || 
                                    eventData.event.metrics.statusSummary.status === 'partialSuccess');
            
            // Determine if it's an error for display based on messages OR status
            const isError = extractedMessages.length > 0 || isFailedStatus;
            
            card.classList.add(isError ? 'is-error' : 'is-event');

            let messagesHtml = '';
            if (extractedMessages.length > 0) {
              messagesHtml = `<div class="mt-2 text-sm text-red-300">
                                <strong>Extracted Messages:</strong>
                                <ul class="list-disc list-inside ml-2">
                                  ${extractedMessages.map(msg => `<li>${msg}</li>`).join('')}
                                </ul>
                              </div>`;
            } else if (isError) {
                // If classified as error but no specific messages were found by extractErrorMessages
                messagesHtml = `<div class="mt-2 text-sm text-red-300">
                                  <strong>Extracted Messages:</strong>
                                  <ul class="list-disc list-inside ml-2">
                                    <li>No specific error message found by extractor, but status indicates an error.</li>
                                  </ul>
                                </div>`;
            }

            card.innerHTML = `
              <div class="flex items-center space-x-3 mb-2">
                <span class="text-xl">â“˜</span>
                <span class="badge ${isError ? 'badge-error' : 'badge-event'}">${isError ? 'Error' : 'Event'}</span>
                <span class="text-gray-400 text-sm">${new Date(eventData.timestamp).toLocaleString()}</span>
              </div>
              <div><strong>Is Error (determined by script):</strong> <span class="${isError ? 'text-red-300' : 'text-blue-300'}">${isError}</span></div>
              <div><strong>Backend isError flag (if present):</strong> <span class="text-gray-400">${eventData.isError !== undefined ? eventData.isError : 'N/A'}</span></div>
              <div><strong>Status Summary (if present):</strong> <span class="text-gray-400">${getNestedProperty(eventData.event, 'metrics.statusSummary.status') || 'N/A'}</span></div>
              ${messagesHtml}
              <h3 class="font-semibold mt-4 mb-2">Raw Payload:</h3>
              <pre>${JSON.stringify(eventData, null, 2)}</pre>
            `;
            
            // Prepend new events
            eventsList.prepend(card);

            // Prune old events from display if limit is exceeded
            while (eventsList.children.length > MAX_DISPLAY_EVENTS) {
                const oldestChild = eventsList.lastChild;
                const oldestEventId = oldestChild.querySelector('pre').textContent.match(/"event_id":\s*"(.*?)"/)?.[1] || oldestChild.querySelector('pre').textContent.match(/"timestamp":\s*(\d+)/)?.[1];
                if (oldestEventId) {
                    displayedEventIds.delete(oldestEventId);
                }
                eventsList.removeChild(oldestChild);
            }
          });

        } catch (error) {
          statusElement.textContent = `Error fetching data: ${error.message}`;
          console.error("Error in diagnostic tool:", error);
        }
      }

      // Initial call and interval setup
      fetchAndDisplayEvents();
      setInterval(fetchAndDisplayEvents, 5000);
    });
  </script>
</body>
</html>
